# Snow32 CPU
<!-- Vim Note:  Use @g to update notes.pdf -->
<!-- Vim Note:  Use @h to update notes.html -->
<!-- Vim Note:  Use @j to update notes.pdf and notes.html -->
<!-- How To Make A Tab:  &emsp; -->
<!--
&epsilon; &Epsilon;   &lambda; &Lambda;   &alpha; &Alpha;
&beta; &Beta;   &pi; &Pi; &#0960;   &sigma; &Sigma;
&omega; &Omega;   &mu; &Mu;  &gamma; &Gamma;
&prod;  &sum;  &int;  &part;  &infin;
&amp;  &ast;  &sdot;
&lt; &le;  &gt; &ge;  &equals; &ne;
-->
#define CONCAT #1#2
#define CONCAT3 CONCAT(CONCAT(#1,#2),#3)
#define CONCAT4 CONCAT(CONCAT3(#1,#2,#3),#4)

#define REG(num) CONCAT(r,num)
#define NAMEDR_LR lr
#define NAMEDR_SP sp
#define SPECREG(num) CONCAT(s,num)
#define NAMEDSPECR_FLAGS flags
#define NAMEDSPECR_INTSTAT intstat
#define NAMEDSPECR_PC pc
#define ENABLE_INTS intstat <= intstat | 0x80000000
#define DISABLE_INTS intstat <= intstat &amp; 0x7fffffff

#define IMM(bits) CONCAT(imm,bits)
#define SIMM(bits) CONCAT(simm,bits)
#define ALUTHREEREGADDRMODE alu\\_addressing\\_mode
#define FLAG(f) CONCAT3(flags<sub>,f,</sub>)
#define CODE(stuff) CONCAT3(<code>,stuff,</code>)
#define MDCODE(stuff) CONCAT3(``,stuff,``)
#define BOLD(stuff) CONCAT3(<b>,stuff,</b>)
#define ITALICS(stuff) CONCAT3(<i>,stuff,</i>)
#define MEM(addr) CONCAT4(byte\\_in\\_mem\\_at,\(,addr,\))
#define MEM2(addr) CONCAT4(two\\_bytes\\_in\\_mem\\_at,\(,addr,\))
#define MEM4(addr) CONCAT4(four\\_bytes\\_in\\_mem\\_at,\(,addr,\))
#define SAY_NOFLAGSAFFECTED Doesn't affect ``flags``.
#define SAY_WHICHFLAGSAFFECTED(which) Affects MDCODE(which) ``flags``.
#define SAY_WHICHFLAGSCANBA(which) Can affect MDCODE(which) ``flags`` if ``f`` encoding bit == 1.
#define SAY_WHICHFLAGSCBA2(which) Can affect MDCODE(which) ``flags`` fi ``f`` encoding bit == 1 **and** ``flags`` is the destination special register.
#define ZEROEXT(stuff) CONCAT3(zero\\_extend\\_to\\_32\(,stuff,\))
#define SIGNEXT(stuff) CONCAT3(sign\\_extend\\_to\\_32\(,stuff,\))
#define ZEROEXT64(stuff) CONCAT3(zero\\_extend\\_to\\_64\(,stuff,\))
#define SIGNEXT64(stuff) CONCAT3(sign\\_extend\\_to\\_64\(,stuff,\))

#define DESCENC_OPCODE Opcode
#define DESCENC_FLAGSAFF if 0, no flags affected.  1 otherwise.
#define DESCENC_REG(num) CODE(REG(num)) &emsp; &emsp; // register number CONCAT3(",num,")
#define DESCENC_SPECR(num) CODE(SPECREG(num)) &emsp; &emsp; // special register number CONCAT3(",num,")
#define DESCENC_EITHERREG(num) (DESCENC_REG(num)) &emsp; **or** &emsp; (DESCENC_SPECR(num))
#define DESCENC_IMM(num) CONCAT(num,-bit) immediate value
#define DESCENC_SIMM(num) sign-extended CONCAT(num,-bits) immediate value
#define DESCENC_EXTRAREGBIT(a,A) 0 if MDCODE(a) is for CONCAT(r,A); 1 if MDCODE(a) is for CONCAT(r,A)

* General Purpose Registers (32-bit)
    * ``r0``, ``r1``, ``r2``, ..., ``r13``, ``r14`` (aka ``lr``), 
    ``r15`` (aka ``sp``)
* Special Purpose Registers (32-bit)
    * ``s0`` (always zero), ``s1`` (aka ``pc``), ``s2`` (aka ``flags``),
    ``s3`` (aka ``intstat``), ``s4`` (aka ``hi``), ``s5`` (aka ``lo``), 
    ``s6``, ``s7``, ... ``s13``, ``s14``, ``s15``
<br>
<br>
* Group 0 Instructions
    * Encoding:  ``0ooo aaaa``
    * ``o``:  DESCENC_OPCODE
    * ``a``:  DESCENC_REG(A)
* <b>add</b> r0, rA
    * Opcode:  0b000
    * Effect:  CODE(r0 <= r0 + rA;)
    * SAY_NOFLAGSAFFECTED
* <b>sub</b> r0, rA
    * Opcode:  0b001
    * Effect:  CODE(r0 <= r0 - rA;)
    * SAY_NOFLAGSAFFECTED
* <b>cmp</b> r0, rA
    * Opcode:  0b010
    * Effect:  CODE(&lt;discard&gt; <= r0 - rA;)
    * SAY_NOFLAGSAFFECTED
* <b>and</b> r0, rA
    * Opcode:  0b011
    * Effect:  CODE(r0 <= r0 &amp; rA;)
    * SAY_NOFLAGSAFFECTED
* <b>orr</b> r0, rA
    * Opcode:  0b100
    * Effect:  CODE(r0 <= r0 | rA;)
    * SAY_NOFLAGSAFFECTED
* <b>xor</b> r0, rA
    * Opcode:  0b101
    * Effect:  CODE(r0 <= r0 ^ rA;)
    * SAY_NOFLAGSAFFECTED
* <b>ldr</b> r0, [rA]
    * Opcode:  0b110
    * Effect:  CODE(r0 <= MEM4(rA);)
    * SAY_NOFLAGSAFFECTED
* <b>str</b> r0, [rA]
    * Opcode:  0b111
    * Effect:  CODE(MEM4(rA) <= r0;)
    * SAY_NOFLAGSAFFECTED
<br>
<br>
* Group 1 Instructions
    * Encoding:  ``1000 ooof  aaaa bbbb``
    * ``o``:  DESCENC_OPCODE
    * ``f``:  DESCENC_FLAGSAFF
    * ``a``:  DESCENC_REG(A)
    * ``b``:  DESCENC_REG(B)
* <b>add</b> rA, rB
    * Opcode:  0b000
    * Effect:  CODE(rA <= rA + rB;)
    * SAY_WHICHFLAGSCANBA(nvzc)
* <b>sub</b> rA, rB
    * Opcode:  0b001
    * Effect:  CODE(rA <= rA - rB;)
    * SAY_WHICHFLAGSCANBA(nvzc)
* <b>cmp</b> rA, rB
    * Opcode:  0b010
    * Effect:  CODE(&lt;discard&gt; <= rA - rB;)
    * SAY_WHICHFLAGSCANBA(nvzc)
* <b>and</b> rA, rB
    * Opcode:  0b011
    * Effect:  CODE(rA <= rA &amp; rB;)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>orr</b> rA, rB
    * Opcode:  0b100
    * Effect:  CODE(rA <= rA | rB;)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>xor</b> rA, rB
    * Opcode:  0b101
    * Effect:  CODE(rA <= rA ^ rB;)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>ldr</b> rA, [rB]
    * Opcode:  0b110
    * Effect:  CODE(rA <= MEM4(rB);)
    * SAY_NOFLAGSAFFECTED
* <b>str</b> rA, [rB]
    * Opcode:  0b111
    * Effect:  CODE(MEM4(rB) <= rA;)
    * SAY_NOFLAGSAFFECTED
<br>
<br>
* Group 2 Instructions
    * Encoding:  ``1001 ooof  aaaa bbbb``
    * ``o``:  DESCENC_OPCODE
    * ``f``:  DESCENC_FLAGSAFF
    * ``a``:  DESCENC_EITHERREG(A)
    * ``b``:  DESCENC_EITHERREG(B)
* <b>adc</b> rA, rB
    * Opcode:  0b000
    * Effect:  CODE(rA <= rA + rB + FLAG(c);)
    * SAY_WHICHFLAGSCANBA(nvzc)
* <b>sbc</b> rA, rB
    * Opcode:  0b001
    * Effect:  CODE(rA <= rA + (~rB) + FLAG(c);)
    * SAY_WHICHFLAGSCANBA(nvzc)
* <b>lsl</b> rA, rB
    * Opcode:  0b010
    * Effect:  CODE(rA <= rA << rB;)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>lsr</b> rA, rB
    * Opcode:  0b011
    * Effect:  CODE(rA <= rA logically right shifted by rB;)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>asr</b> rA, rB
    * Opcode:  0b100
    * Effect:  CODE(rA <= rA arithmetic right shifted by rB;)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>mul</b> rA, rB
    * Opcode:  0b101
    * Effect:  CODE(rA <= rA &ast; rB;)
    * SAY_NOFLAGSAFFECTED
* <b>cpy</b> rA, sB
    * Opcode:  0b110
    * Effect:  CODE(rA <= sB;)
    * SAY_NOFLAGSAFFECTED
* <b>cpy</b> sA, rB
    * Opcode:  0b111
    * Effect:  CODE(sA <= rB;)
    * SAY_WHICHFLAGSCBA2(nvzc)
<br>
<br>
* Group 3 Instructions
    * Encoding:  ``1010 ooof  aaaa bbbb  iiii iiii iiii iiii``
    * ``o``:  DESCENC_OPCODE
    * ``f``:  DESCENC_FLAGSAFF
    * ``a``:  DESCENC_REG(A)
    * ``b``:  DESCENC_REG(B)
    * ``i``:  DESCENC_IMM(16)
* <b>addi</b> rA, rB, IMM(16)
    * Opcode:  0b000
    * Effect:  CODE(rA <= rB + ZEROEXT(IMM(16));)
    * SAY_WHICHFLAGSCANBA(nvzc)
* <b>subi</b> rA, rB, IMM(16)
    * Opcode:  0b001
    * Effect:  CODE(rA <= rB - ZEROEXT(IMM(16));)
    * SAY_WHICHFLAGSCANBA(nvzc)
* <b>cmpi</b> rA, IMM(16)
    * Opcode:  0b010
    * Effect:  CODE(&lt;discard&gt; <= rA - ZEROEXT(IMM(16));)
    * SAY_WHICHFLAGSCANBA(nvzc)
* <b>andi</b> rA, rB, IMM(16)
    * Opcode:  0b011
    * Effect:  CODE(rA <= rB &amp; ZEROEXT(IMM(16));)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>orri</b> rA, rB, IMM(16)
    * Opcode:  0b100
    * Effect:  CODE(rA <= rB | ZEROEXT(IMM(16));)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>xori</b> rA, rB, IMM(16)
    * Opcode:  0b101
    * Effect:  CODE(rA <= rB ^ ZEROEXT(IMM(16));)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>ldrxi</b> rA, [rB, IMM(16)]
    * Opcode:  0b110
    * Effect:  CODE(rA <= MEM4(rB + ZEROEXT(IMM(16)));)
    * SAY_NOFLAGSAFFECTED
* <b>strxi</b> rA, [rB, IMM(16)]
    * Opcode:  0b111
    * Effect:  CODE(MEM4(rB + ZEROEXT(IMM(16))) <= rA;)
    * SAY_NOFLAGSAFFECTED
<br>
<br>
* Group 4 Instructions
    * Encoding:  ``1011 ooof  aaaa bbbb  iiii iiii iiii iiii``
    * ``o``:  DESCENC_OPCODE
    * ``f``:  DESCENC_FLAGSAFF
    * ``a``:  DESCENC_REG(A)
    * ``b``:  DESCENC_EITHERREG(B)
    * ``i``:  DESCENC_IMM(16)
* <b>adci</b> rA, rB, IMM(16)
    * Opcode:  0b000
    * Effect:  CODE(rA <= rB + ZEROEXT(IMM(16)) + FLAG(c);)
    * SAY_WHICHFLAGSCANBA(nvzc)
* <b>sbci</b> rA, rB, IMM(16)
    * Opcode:  0b001
    * Effect:  CODE(rA <= rB + (~ZEROEXT(IMM(16))) + FLAG(c);)
    * SAY_WHICHFLAGSCANBA(nvzc)
* <b>lsli</b> rA, rB, IMM(16)
    * Opcode:  0b010
    * Effect:  CODE(rA <= rB << IMM(16);)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>lsri</b> rA, rB, IMM(16)
    * Opcode:  0b011
    * Effect:  CODE(rA <= rB logically right shifted by IMM(16);)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>asri</b> rA, rB, IMM(16)
    * Opcode:  0b100
    * Effect:  CODE(rA <= rB arithmetic right shifted by IMM(16);)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>addsi</b> rA, sB, IMM(16)
    * Opcode:  0b101
    * Effect:  CODE(rA <= sB + SIGNEXT(IMM(16));)
    * SAY_NOFLAGSAFFECTED
* <b>cpysi</b> rA, IMM(16)
    * Opcode:  0b110
    * Effect:  CODE(rA <= SIGNEXT(IMM(16);))
    * SAY_NOFLAGSAFFECTED
* <b>cpyihi</b> rA, IMM(16)
    * Opcode:  0b111
    * Effect:  CODE(rA[31:16] <= IMM(16);)
    * SAY_NOFLAGSAFFECTED
<br>
<br>
* Group 5 Instructions
    * Encoding:  ``1100 oooo  iiii iiii``
    * ``o``:  DESCENC_OPCODE
    * ``i``:  DESCENC_IMM(8)
* <b>bra</b> IMM(8)
    * Opcode:  0b0000
    * Effect:  CODE(pc <= pc + SIGNEXT(IMM(8);))
    * SAY_NOFLAGSAFFECTED
* <b>bnv</b> IMM(8)
    * Opcode:  0b0001
    * Effect:  CODE(pc <= pc + 0;)
    * SAY_NOFLAGSAFFECTED
* <b>bne</b> IMM(8)
    * Opcode:  0b0010
    * Effect:  <code>if (FLAG(z) == 0) begin pc <= pc + SIGNEXT(IMM(8));
    end</code>
    * SAY_NOFLAGSAFFECTED
* <b>beq</b> IMM(8)
    * Opcode:  0b0011
    * Effect:  <code>if (FLAG(z) == 1) begin pc <= pc + SIGNEXT(IMM(8));
    end</code>
    * SAY_NOFLAGSAFFECTED
* <b>bcc</b> IMM(8)
    * Opcode:  0b0100
    * Effect:  <code>if (FLAG(c) == 0) begin pc <= pc + SIGNEXT(IMM(8));
    end</code>
    * Note:  unsigned less than
    * SAY_NOFLAGSAFFECTED
* <b>bcs</b> IMM(8)
    * Opcode:  0b0101
    * Effect:  <code>if (FLAG(c) == 1) begin pc <= pc + SIGNEXT(IMM(8));
    end</code>
    * Note:  unsigned greater than or equal
    * SAY_NOFLAGSAFFECTED
* <b>bls</b> IMM(8)
    * Opcode:  0b0110
    * Effect:  <code>if ((FLAG(c) == 0) || (FLAG(z) == 1))
    begin 
        pc <= pc + SIGNEXT(IMM(8));
    end</code>
    * Note:  unsigned less than or equal
    * SAY_NOFLAGSAFFECTED
* <b>bhi</b> IMM(8)
    * Opcode:  0b0111
    * Effect:  <code>if (FLAG(c) == 1) &amp;&amp; FLAG(z) == 0) 
    begin 
        pc <= pc + SIGNEXT(IMM(8));
    end</code>
    * Note:  unsigned greater than
    * SAY_NOFLAGSAFFECTED
* <b>bvc</b> IMM(8)
    * Opcode:  0b1000
    * Effect:  <code>if (FLAG(v) == 0) 
    begin 
        pc <= pc + SIGNEXT(IMM(8));
    end</code>
    * SAY_NOFLAGSAFFECTED
* <b>bvs</b> IMM(8)
    * Opcode:  0b1001
    * Effect:  <code>if (FLAG(v) == 1) 
    begin 
        pc <= pc + SIGNEXT(IMM(8));
    end</code>
    * SAY_NOFLAGSAFFECTED
* <b>bpl</b> IMM(8)
    * Opcode:  0b1010
    * Effect:  <code>if (FLAG(n) == 0) 
    begin 
        pc <= pc + SIGNEXT(IMM(8));
    end</code>
    * SAY_NOFLAGSAFFECTED
* <b>bmi</b> IMM(8)
    * Opcode:  0b1011
    * Effect:  <code>if (FLAG(n) == 1) 
    begin 
        pc <= pc + SIGNEXT(IMM(8));
    end</code>
    * SAY_NOFLAGSAFFECTED
* <b>blt</b> IMM(8)
    * Opcode:  0b1100
    * Effect:  <code>if (FLAG(n) != FLAG(v))
    begin
        pc <= pc + SIGNEXT(IMM(8));
    end</code>
    * Note:  signed less than
    * SAY_NOFLAGSAFFECTED
* <b>bge</b> IMM(8)
    * Opcode:  0b1101
    * Effect:  <code>if (FLAG(n) == FLAG(v))
    begin
        pc <= pc + SIGNEXT(IMM(8));
    end</code>
    * Note:  signed greater than or equal
    * SAY_NOFLAGSAFFECTED
* <b>ble</b> IMM(8)
    * Opcode:  0b1110
    * Effect:  <code>if ((FLAG(n) != FLAG(v)) && (FLAG(Z) == 0))
    begin
        pc <= pc + SIGNEXT(IMM(8));
    end</code>
    * Note:  signed less than
    * SAY_NOFLAGSAFFECTED
* <b>bgt</b> IMM(8)
    * Opcode:  0b1111
    * Effect:  <code>if ((FLAG(n) == FLAG(v)) || (FLAG(Z) == 1))
    begin
        pc <= pc + SIGNEXT(IMM(8));
    end</code>
    * Note:  signed greater than or equal
    * SAY_NOFLAGSAFFECTED
<br>
<br>
* Group 6 Instructions
    * Encoding:  ``1101 oooo  aaaa bbbb``
    * ``o``:  DESCENC_OPCODE
    * ``a``:  DESCENC_EITHERREG(A)
    * ``b``:  DESCENC_EITHERREG(B)
* <b>ei</b>
    * Opcode:  0b0000
    * Effect:  ENABLE_INTS
    * SAY_NOFLAGSAFFECTED
* <b>di</b>
    * Opcode:  0b0001
    * Effect:  ENABLE_INTS
    * SAY_NOFLAGSAFFECTED
* <b>push</b> rA, [rB]
    * Opcode:  0b0010
    * Effect:  CODE(MEM4(rB) = rA; rB = rB - 4; )
    * SAY_NOFLAGSAFFECTED
* <b>pop</b> rA, [rB]
    * Opcode:  0b0011
    * Effect:  CODE(rB = rB + 4; rA = MEM4(rB);)
    * SAY_NOFLAGSAFFECTED
* <b>push</b> sA, [rB]
    * Opcode:  0b0100
    * Effect:  CODE(MEM4(rB) = sA; rB = rB - 4; )
    * SAY_NOFLAGSAFFECTED
* <b>pop</b> sA, [rB]
    * Opcode:  0b0101
    * Effect:  CODE(rB = rB + 4; sA = MEM4(rB);)
    * SAY_NOFLAGSAFFECTED
* <b>ldb</b> rA, [rB]
    * Opcode:  0b0110
    * Effect:  CODE(rA <= ZEROEXT(MEM(rB));)
    * SAY_NOFLAGSAFFECTED
* <b>ldsb</b> rA, [rB]
    * Opcode:  0b0111
    * Effect:  CODE(rA <= SIGNEXT(MEM(rB));)
    * SAY_NOFLAGSAFFECTED
* <b>stb</b> rA, [rB]
    * Opcode:  0b1000
    * Effect:  CODE(MEM(rB) <= (rA[7:0]);)
    * SAY_NOFLAGSAFFECTED
* <b>ldh</b> rA, [rB]
    * Opcode:  0b1001
    * Effect:  CODE(rA <= ZEROEXT(MEM2(rB));)
    * SAY_NOFLAGSAFFECTED
* <b>ldsh</b> rA, [rB]
    * Opcode:  0b1010
    * Effect:  CODE(rA <= SIGNEXT(MEM2(rB));)
    * SAY_NOFLAGSAFFECTED
* <b>sth</b> rA, [rB]
    * Opcode:  0b1011
    * Effect:  CODE(MEM2(rB) <= (rA[15:0]);)
    * SAY_NOFLAGSAFFECTED
* <b>ldr</b> rA, [sB]
    * Opcode:  0b1100
    * Effect:  CODE(rA <= MEM4(sB);)
    * SAY_NOFLAGSAFFECTED
* <b>str</b> rA, [sB]
    * Opcode:  0b1101
    * Effect:  CODE(MEM4(sB) <= rA;)
    * SAY_NOFLAGSAFFECTED
* <b>call</b> rA
    * Opcode:  0b1110
    * Effect:  CODE(lr <= pc + 2; pc <= rA;)
    * SAY_NOFLAGSAFFECTED
* <b>add</b> pc, rA, rB
    * Opcode:  0b1111
    * Effect:  CODE(pc <= rA + rB;)
    * Note:  Shorter encoding for equivalent Group 8 instruction
    * SAY_NOFLAGSAFFECTED
<br>
<br>
* Group 7 Instruction
    * Encoding:  ``1110 iiii  iiii iiii  iiii iiii  iiii iiii``
    * ``i``:  DESCENC_IMM(28)
* <b>callr</b> 
    * Effect:  CODE(lr <= pc + 2; pc <= pc + SIGNEXT(IMM(28));)
    * SAY_NOFLAGSAFFECTED
<br>
<br>
* Group 8 Instructions
    * Encoding:  ``1111 0000  dddf aaaa  bbbb cccc  xyzo oooo``
    * ``o``:  DESCENC_OPCODE
    * ``d``:  ALU instruction addressing mode
    * ``f``:  DESCENC_FLAGSAFF
    * ``a``:  DESCENC_EITHERREG(A)
    * ``b``:  DESCENC_EITHERREG(B)
    * ``c``:  DESCENC_EITHERREG(C)
    * ``x``:  DESCENC_EXTRAREGBIT(a,A)
    * ``y``:  DESCENC_EXTRAREGBIT(b,B)
    * ``z``:  DESCENC_EXTRAREGBIT(c,C)
* ALU Instruction Addressing Modes:
    * ALU Instr Addressing Mode bits:  0b000
        * <b>&lt;aluop\\_non\\_cmp&gt;</b> rsA, rsB, rsC
            * Arguments:  dst:  rsA, Arg1:  rsB, Arg2:  rsC
        * <b>&lt;cmp&gt;</b> rsB, rsC
            * Arguments:  Arg1:  rsB, Arg2:  rsC
    * ALU Instr Addressing Mode bits:  0b001
        * <b>&lt;aluop&gt;</b> rsA, [rsB, rsC]
            * Arguments:  dst:  rsA, Arg1:  rsA, Arg2:  MEM(rsB + rsB)
* Note:  "rsX" means "rX" **or** "sX"
* Note:  If dst is ``flags``, then ``flags`` won't be written.
* <b>add</b> ALUTHREEREGADDRMODE
    * Opcode:  0b00000
    * Effect:  CODE(dst <= Arg1 + Arg2;)
    * SAY_WHICHFLAGSCANBA(nvzc)
* <b>sub</b> ALUTHREEREGADDRMODE
    * Opcode:  0b00001
    * Effect:  CODE(dst <= Arg1 - Arg2;)
    * SAY_WHICHFLAGSCANBA(nvzc)
* <b>cmp</b> ALUTHREEREGADDRMODE
    * Opcode:  0b00010
    * Effect:  CODE(&lt;discard&gt; <= Arg1 - Arg2;)
    * SAY_WHICHFLAGSCANBA(nvzc)
* <b>and</b> ALUTHREEREGADDRMODE
    * Opcode:  0b00011
    * Effect:  CODE(dst <= Arg1 &amp; Arg2;)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>orr</b> ALUTHREEREGADDRMODE
    * Opcode:  0b00100
    * Effect:  CODE(dst <= Arg1 | Arg2;)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>xor</b> ALUTHREEREGADDRMODE
    * Opcode:  0b00101
    * Effect:  CODE(dst <= Arg1 ^ Arg2;)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>ldrx</b> rsA, [rsB, rsC]
    * Opcode:  0b00110
    * Effect:  CODE(rsA <= MEM4(rsB + rsC);)
    * SAY_NOFLAGSAFFECTED
* <b>strx</b> rsA, [rsB, rsC]
    * Opcode:  0b00111
    * Effect:  CODE(MEM4(rsB + rsC) <= rsA;)
    * SAY_NOFLAGSAFFECTED
* <b>adc</b> ALUTHREEREGADDRMODE
    * Opcode:  0b01000
    * Effect:  CODE(dst <= Arg1 + Arg2 + FLAG(C);)
    * SAY_WHICHFLAGSCANBA(nvzc)
* <b>sbc</b> ALUTHREEREGADDRMODE
    * Opcode:  0b01001
    * Effect:  CODE(dst <= Arg1 + (~Arg2) + FLAG(C);)
    * SAY_WHICHFLAGSCANBA(nvzc)
* <b>lsl</b> ALUTHREEREGADDRMODE
    * Opcode:  0b01010
    * Effect:  CODE(dst <= Arg1 << Arg2;)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>lsr</b> ALUTHREEREGADDRMODE
    * Opcode:  0b01011
    * Effect:  CODE(dst <= Arg1 logically right shifted by Arg2;)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>asr</b> ALUTHREEREGADDRMODE
    * Opcode:  0b01100
    * Effect:  CODE(dst <= Arg1 arithmetic right shifted by Arg2;)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>rol</b> ALUTHREEREGADDRMODE
    * Opcode:  0b01101
    * Effect:  CODE(dst <= Arg1 rotated left by Arg2;)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>ror</b> ALUTHREEREGADDRMODE
    * Opcode:  0b01110
    * Effect:  CODE(dst <= Arg1 rotated right by Arg2;)
    * SAY_WHICHFLAGSCANBA(nz)
* <b>umull</b> rsA, rsB
    * Opcode:  0b01111
    * Effect:  <code>{hi, lo} <= ZEROEXT64(rsA)
    &ast; ZEROEXT64(rsB);</code>
    * SAY_WHICHFLAGSCANBA(nz)
* <b>smull</b> rsA, rsB
    * Opcode:  0b01111
    * Effect:  <code>{hi, lo} <= SIGNEXT64(rsA) 
    &ast; SIGNEXT64(rsB);</code>
    * SAY_WHICHFLAGSCANBA(nz)
* <b>ldbx</b> rsA, [rsB, rsC]
    * Opcode:  0b10001
    * Effect:  CODE(rsA <= ZEROEXT(MEM(rsB + rsC));)
    * SAY_NOFLAGSAFFECTED
* <b>ldsbx</b> rsA, [rsB, rsC]
    * Opcode:  0b10010
    * Effect:  CODE(rsA <= SIGNEXT(MEM(rsB + rsC));)
    * SAY_NOFLAGSAFFECTED
* <b>stbx</b> rsA, [rsB, rsC]
    * Opcode:  0b10011
    * Effect:  CODE(MEM(rsB + rsC) <= (rsA[7:0]);)
    * SAY_NOFLAGSAFFECTED
* <b>ldhx</b> rsA, [rsB, rsC]
    * Opcode:  0b10100
    * Effect:  CODE(rsA <= ZEROEXT(MEM2(rsB + rsC));)
    * SAY_NOFLAGSAFFECTED
* <b>ldshx</b> rsA, [rsB, rsC]
    * Opcode:  0b10101
    * Effect:  CODE(rsA <= SIGNEXT(MEM2(rsB + rsC));)
    * SAY_NOFLAGSAFFECTED
* <b>sthx</b> rsA, [rsB, rsC]
    * Opcode:  0b10110
    * Effect:  CODE(MEM2(rsB + rsC) <= (rsA[15:0]);)
    * SAY_NOFLAGSAFFECTED
